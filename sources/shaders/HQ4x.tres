[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;


uniform vec2 SCALE = vec2(4,4);

uniform sampler2D LUT;
uniform int FrameDirection;
uniform int FrameCount;
uniform vec2 OutputSize;
uniform vec2 TextureSize;
uniform vec2 InputSize;

varying vec4 vTexCoord[4];

const mat3 yuv_matrix = mat3(vec3(0.299, 0.587, 0.114), vec3(-0.169, -0.331, 0.5), vec3(0.5, -0.419, -0.081));
const vec3 yuv_threshold = vec3(48.0/255.0, 7.0/255.0, 6.0/255.0);
const vec3 yuv_offset = vec3(0, 0.5, 0.5);

bool diff(vec3 yuv1, vec3 yuv2)
{
	bvec3 res = greaterThan(abs((yuv1 + yuv_offset) - (yuv2 + yuv_offset)), yuv_threshold);
	return res.x || res.y || res.z;
}

void fragment()
{
	vec2 fp = fract(vTexCoord[0].xy*TextureSize);
	vec2 quad = sign(-0.5 + fp);
	mat3 yuv = transpose(yuv_matrix);

	float dx = vTexCoord[0].z;
	float dy = vTexCoord[0].w;
	vec3 p1  = texture(TEXTURE, vTexCoord[0].xy).rgb;
	vec3 p2  = texture(TEXTURE, vTexCoord[0].xy + vec2(dx, dy) * quad).rgb;
	vec3 p3  = texture(TEXTURE, vTexCoord[0].xy + vec2(dx, 0) * quad).rgb;
	vec3 p4  = texture(TEXTURE, vTexCoord[0].xy + vec2(0, dy) * quad).rgb;
	mat4 pixels = mat4(vec4(p1, 0), vec4(p2, 0), vec4(p3, 0), vec4(p4, 0));

	vec3 w1  = yuv * texture(TEXTURE, vTexCoord[1].xw).rgb;
	vec3 w2  = yuv * texture(TEXTURE, vTexCoord[1].yw).rgb;
	vec3 w3  = yuv * texture(TEXTURE, vTexCoord[1].zw).rgb;

	vec3 w4  = yuv * texture(TEXTURE, vTexCoord[2].xw).rgb;
	vec3 w5  = yuv * p1;
	vec3 w6  = yuv * texture(TEXTURE, vTexCoord[2].zw).rgb;

	vec3 w7  = yuv * texture(TEXTURE, vTexCoord[3].xw).rgb;
	vec3 w8  = yuv * texture(TEXTURE, vTexCoord[3].yw).rgb;
	vec3 w9  = yuv * texture(TEXTURE, vTexCoord[3].zw).rgb;

	bvec3 pattern[3];
	pattern[0] =  bvec3(diff(w5, w1), diff(w5, w2), diff(w5, w3));
	pattern[1] =  bvec3(diff(w5, w4), false       , diff(w5, w6));
	pattern[2] =  bvec3(diff(w5, w7), diff(w5, w8), diff(w5, w9));
	bvec4 cross = bvec4(diff(w4, w2), diff(w2, w6), diff(w8, w4), diff(w6, w8));

	vec2 index;
	index.x = dot(vec3(pattern[0]), vec3(1, 2, 4)) +
			  dot(vec3(pattern[1]), vec3(8, 0, 16)) +
			  dot(vec3(pattern[2]), vec3(32, 64, 128));
	index.y = dot(vec4(cross), vec4(1, 2, 4, 8)) * (SCALE.x * SCALE.x) +
	          dot(floor(fp * SCALE), vec2(1, 4));

	vec2 step = 1.0 / vec2(256.0, 16.0 * (SCALE.x * SCALE.x));
	vec2 offset = step / 2.0;
	vec4 weights = texture(LUT, index * step + offset,0);
	float sum = dot(weights, vec4(1));
	vec4 res = pixels * (weights / sum);

	COLOR = res;
}

/*
Made with a whole lot of nightmare fuel.
Logic's Under Pressure and Bobby Tarantino II Albums was in rotation during
the making process.
Hope you enjoy!

You're auto-friended to me if you're a Logic fan
RattPack all day!


//image mipmap level, for base upscaling
const int ML = 0;

//equality threshold of 2 colors before forming lines
uniform float THRESHOLD = 0.01;

//anti aliasing scaling, smaller value make lines more blurry
uniform float AA_SCALE = 10.0;

//draw diagonal line connecting 2 pixels if within threshold
bool diag(inout vec4 sum, vec2 uv, vec2 p1, vec2 p2, sampler2D iChannel0, float LINE_THICKNESS) {
    vec4 v1 = texelFetch(iChannel0,ivec2(uv+vec2(p1.x,p1.y)),ML),
        v2 = texelFetch(iChannel0,ivec2(uv+vec2(p2.x,p2.y)),ML);
    if (length(v1-v2) < THRESHOLD) {
    	vec2 dir = p2-p1,
            lp = uv-(floor(uv+p1)+.5);
    	dir = normalize(vec2(dir.y,-dir.x));
        float l = clamp((LINE_THICKNESS-dot(lp,dir))*AA_SCALE,0.,1.);
        sum = mix(sum,v1,l);
    	return true;
    }
    return false;
}

void fragment(){
	//line thickness
	float LINE_THICKNESS;
	vec2 ip = UV * (1.0 / TEXTURE_PIXEL_SIZE);
	
	
		//start with nearest pixel as 'background'
		vec4 s = texelFetch(TEXTURE,ivec2(int(ip.x),int(ip.y)),ML);
		
		//draw anti aliased diagonal lines of surrounding pixels as 'foreground'
		LINE_THICKNESS = 0.4;
		if (diag(s,ip,vec2(-1,0),vec2(0,1), TEXTURE, LINE_THICKNESS)) {
			LINE_THICKNESS = 0.3;
			diag(s,ip,vec2(-1,0),vec2(1,1), TEXTURE, LINE_THICKNESS);
			diag(s,ip,vec2(-1,-1),vec2(0,1), TEXTURE, LINE_THICKNESS);
		}
		LINE_THICKNESS = 0.4;
		if (diag(s,ip,vec2(0,1),vec2(1,0), TEXTURE, LINE_THICKNESS)) {
			LINE_THICKNESS = 0.3;
			diag(s,ip,vec2(0,1),vec2(1,-1), TEXTURE, LINE_THICKNESS);
			diag(s,ip,vec2(-1,1),vec2(1,0), TEXTURE, LINE_THICKNESS);
		}
		LINE_THICKNESS = 0.4;
		if (diag(s,ip,vec2(1,0),vec2(0,-1), TEXTURE, LINE_THICKNESS)) {
			LINE_THICKNESS = 0.3;
			diag(s,ip,vec2(1,0),vec2(-1,-1), TEXTURE, LINE_THICKNESS);
			diag(s,ip,vec2(1,1),vec2(0,-1), TEXTURE, LINE_THICKNESS);
		}
		LINE_THICKNESS = 0.4;
		if (diag(s,ip,vec2(0,-1),vec2(-1,0), TEXTURE, LINE_THICKNESS)) {
			LINE_THICKNESS = 0.3;
			diag(s,ip,vec2(0,-1),vec2(-1,1), TEXTURE, LINE_THICKNESS);
			diag(s,ip,vec2(1,-1),vec2(-1,0), TEXTURE, LINE_THICKNESS);
	 	}
		
		COLOR = s;
}
*/"
